# 📘 Study Guide: Recipe for Computing

## 🧾 Introduction

Computers follow instructions — but how are those instructions written and translated for machines to understand? This guide explains the history and evolution of how we write programs, starting from binary punch cards all the way to modern interpreted languages. Whether you're new to programming or brushing up on fundamentals, this will walk you through it clearly.

---

## 💾 Programming in the 1950s: Punch Cards

In the early days of computing (around the 1950s), programs were stored and executed using **punch cards**.

- Each **punch card** physically represented **bits** (binary values of 0s and 1s).
- A stack of punch cards formed an entire program.
- The CPU would read the binary instructions off these cards and perform operations like:
  - Fetch input data from a memory address
  - Perform calculations
  - Store results in memory

🧠 **Why it was difficult:**  
Writing programs using punch cards was:
- **Tedious**: required large stacks
- **Error-prone**: one wrong hole, and the program might break
- **Slow to debug or update**

---

## 🛠️ Assembly Language: A Better Way

To solve the punch card limitations, **assembly language** was created.

- Assembly is a **low-level programming language** that uses human-readable instructions.
- These instructions correspond directly to machine instructions.
- Example:
  ```assembly
  MOV R1, 5       ; Move integer 5 into Register 1
  MOV R2, 3       ; Move integer 3 into Register 2
  ADD R4, R1, R2  ; Add contents of R1 and R2, store result in R4
  ```

🧠 **Benefits:**
- Easier to read than binary
- Still very close to machine code
- **Downside**: Assembly language is hardware-specific — a program written for one CPU likely won’t run on another.

---

## 🧮 Enter Compiled Programming Languages

To write code that works on multiple CPU types, **compiled programming languages** were invented.

### 🔄 What is Compilation?

- A **compiled language** lets you write code using human-readable syntax.
- This code is then passed through a **compiler** — a program that translates your code into **machine code** tailored to a specific CPU.
- This allows programmers to write once, then deploy efficiently.

### 👩‍💻 Admiral Grace Hopper's Contribution

- Grace Hopper pioneered early compilers, making programming more accessible.
- Her work laid the foundation for high-level languages like COBOL and modern tools.

### 🔤 Example:
- High-level code:
  ```c
  int a = 5;
  int b = 3;
  int sum = a + b;
  ```
- After compilation, this is turned into machine instructions behind the scenes.

---

## 📜 Interpreted Languages & Scripts

Not all languages are compiled in advance. Some are **interpreted**.

### 📘 Interpreted Languages:

- Code is executed **line-by-line** at runtime using an **interpreter**.
- You write a file (called a **script**) and run it directly.
- These are not compiled beforehand.

🧠 **Why use them?**
- Easier to test and iterate quickly
- Great for small tasks or automation
- Common in IT scripting (e.g., Python, Bash)

🛠 **Interpreter vs Compiler**
| Compiler                            | Interpreter                        |
|-------------------------------------|------------------------------------|
| Converts entire program to machine code before running | Translates code line-by-line while running |
| Usually faster execution            | Easier for rapid development       |
| Needs a compile step                | No need to compile manually        |

---

## 🤖 Scripting in IT Support

As an **IT Support Specialist**, scripting is your secret weapon.

- Automate routine tasks (e.g., backups, installations, service restarts)
- Solve a problem once, then reuse the solution via a script
- Languages like **PowerShell**, **Bash**, or **Python** are especially useful

🎯 Example:
Instead of manually restarting 10 printers, write a PowerShell script that does it all at once.

---

## 🧠 Summary

| Concept                  | Description |
|--------------------------|-------------|
| **Punch Cards**          | Physical cards representing binary instructions |
| **Assembly Language**    | Low-level readable code, CPU-specific |
| **Compiled Languages**   | Translated to machine code by a compiler (e.g., C, C++) |
| **Interpreter Languages**| Run directly by an interpreter, used for scripting |
| **Scripts**              | Files containing code written in an interpreted language |
| **Compiler**             | Tool that turns code into machine code |
| **Interpreter**          | Tool that runs code directly without compiling |

---

## 📚 Glossary of Terms

| Term           | Definition |
|----------------|------------|
| **Bit**        | A binary digit, 0 or 1 — the smallest unit of data |
| **Punch Card** | Paper card used to encode programs with holes representing bits |
| **CPU**        | Central Processing Unit — executes instructions |
| **Assembly Language** | Low-level language that corresponds closely with machine code |
| **Register**   | Small storage location inside the CPU |
| **Compiler**   | Translates high-level code into machine code before execution |
| **Interpreter**| Translates and executes code line-by-line at runtime |
| **Script**     | A file containing code in an interpreted language |
| **Grace Hopper** | Computer scientist and inventor of the compiler |
| **Scripting Language** | A type of programming language used to automate tasks |

---

## 🧪 Test Your Understanding

1. What were the limitations of punch cards?
2. Why is assembly language still considered low-level?
3. What is the benefit of a compiled language vs an interpreted one?
4. Why are scripts useful in IT support roles?

---

End of guide. ✨
